---
description: Guidelines for creating comprehensive GitHub pull requests for DuckDuckGo browser, including template structure, contributor analysis, and tooling instructions. "pull request" "PR creation" "github" "code review" "git"
globs: 
alwaysApply: false
---
# GitHub Pull Request Creation Guidelines

## Overview
This rule provides guidelines for creating comprehensive pull requests for the DuckDuckGo browser codebase following the established PR template and engineering expectations.

## Quick Start (TL;DR)

**Fastest PR Creation:**
```bash
# 1. Create branch with username prefix (e.g., alex/feature-name)
git checkout -b username/feature-description origin/main

# 2. Commit and push (sets upstream automatically)
git add .
git commit -m "Brief description"
git push -u origin $(git branch --show-current)

# 3. Create PR (opens in browser for editing)
gh pr create --fill-verbose --web --label "pending ship review"
```

**Essential PR Checklist:**
- [ ] Task/Issue URL provided
- [ ] Impact level specified (High/Medium/Low)
- [ ] Testing steps included
- [ ] "pending ship review" label for UI changes
- [ ] Contributors CC'd (use `gh api repos/duckduckgo/apple-browsers/collaborators --jq '.[].login'`)

**Common Labels:** `pending ship review`, `feature`, `bug`, `performance`, `security`

## Branch Naming Convention

### Required Format: `username/feature-description`
- **Always include your username** as prefix (e.g., `alex/`, `john/`, `sarah/`)
- **Use descriptive feature names** that clearly indicate the change
- **Use hyphens** to separate words in the description
- **Keep it concise** but descriptive

**Examples:**
- `alex/delete-browsing-data-menu`
- `john/fix-bookmark-sync-crash`
- `sarah/improve-privacy-dashboard`

**Why username prefixes?**
- Prevents branch name conflicts between team members
- Makes it clear who owns each branch
- Easier to track and manage branches
- Follows DuckDuckGo team conventions

## Important Notes

### Keep It Practical
- **Go through the template systematically** but don't overcomplicate things
- **Be thorough but concise** - provide necessary information without excessive detail
- **Focus on what reviewers need to know** to evaluate your code changes
- **Remove template sections** that genuinely don't apply to your change

### Review Process Separation
- **PR Review**: Focuses on code quality, architecture, security, and functionality
- **Ship Review**: Evaluates UX impact and user-facing changes (shouldn't be in scope of the PR description)
- **UX impact evaluation is NOT part of PR review** - it happens during Ship review

### UI/Interaction Changes
- **Add "pending ship review" label** to PRs that modify:
  - User interface elements
  - User interactions or workflows  
  - Visual design or layout
  - User-facing messaging or copy
- **Ship review** will evaluate UX impact before release

## PR Template Structure

### Required Information Collection
Before creating a PR, always gather:

1. **Task/Issue URL**: MUST be provided or explicitly asked for
   - If not provided: "Please provide the Task/Issue URL for this change"
   - Should link to Asana task or GitHub issue
   
2. **Tech Design URL**: Include if one exists
   - Can be skipped if no tech design was created
   - Required if there's an existing tech design document for the change
   
3. **CC**: Contributors to modified code areas
   - Analyze git history/blame for modified files to identify key contributors
   - CC the most active contributors to the affected code areas
   - Choose the most valuable contributor as the primary reviewer

### Description Guidelines

#### Content Requirements
- **Clear and Concise**: Explain what the change does, not how it works
- **User-Focused**: Describe the benefit or problem being solved
- **Context**: Provide enough background for reviewers unfamiliar with the area
- **Screenshots/Videos**: Required only for non-obvious features/bugs or complex UI changes

#### Good Description Examples
```
# Good
Adds delete browsing data functionality to the main menu, allowing users to quickly clear their browsing history, cookies, and cache without navigating to settings.

# Bad  
Implemented the delete browsing data feature by adding new view models and UI components.
```

### Testing Steps Analysis

#### Change Type Detection
Analyze the code changes to determine appropriate testing steps:

**UI Changes**:
- Include steps for different screen sizes (iPhone, iPad, macOS)
- Test light/dark mode variations
- Verify accessibility features
- Test with different system settings (text size, etc.)
- Include screenshots/videos only for non-obvious changes or complex interactions

**Feature Changes**:
- Test happy path scenarios
- Test edge cases and error conditions
- Verify integration with existing features
- Test data persistence/clearing

**API/Service Changes**:
- Test network conditions (offline, slow connection)
- Verify error handling
- Test concurrent operations
- Validate data integrity

**Privacy/Security Changes**:
- Verify data clearing mechanisms
- Test fireproofing behavior
- Validate secure storage usage
- Test privacy dashboard updates

#### Testing Steps Format
1. **Preconditions**: What state should the app be in?
2. **Actions**: Step-by-step instructions
3. **Expected Results**: What should happen at each step
4. **Verification**: How to confirm the change works

Example:
```
1. Open DuckDuckGo browser with existing browsing history
2. Navigate to main menu → "Clear Browsing Data"
3. Select "All Time" and check all data types
4. Tap "Clear Data" and confirm
5. Expected: All browsing data cleared, confirmation message shown
6. Verify: History tab is empty, no saved passwords remain
```

### Impact and Risk Assessment

#### Impact Level Classification
**High Impact** - Requires extra scrutiny:
- Changes to WebView handling or content blocking
- Authentication/credential management
- Data storage/clearing mechanisms
- Network security features
- Core browsing functionality

**Medium Impact**:
- New features that affect user workflows
- Settings or preferences changes
- UI/UX modifications to existing features
- Performance optimizations

**Low Impact**:
- Bug fixes for non-critical issues
- Minor UI adjustments
- Internal refactoring without behavior changes
- Documentation updates

#### Risk Analysis Questions
Always address:
- **Data Loss**: Could this change cause users to lose data?
- **Privacy**: Could this expose user information?
- **Security**: Does this introduce security vulnerabilities?
- **Performance**: Could this degrade app performance?
- **Compatibility**: Does this break existing functionality?
- **Edge Cases**: What happens in unusual scenarios?

### Quality Considerations Checklist

#### Privacy & Security Review
- [ ] No hardcoded secrets or API keys
- [ ] Sensitive data properly encrypted/stored
- [ ] User data clearing mechanisms tested
- [ ] Privacy dashboard reflects changes
- [ ] Follows fireproofing patterns if applicable

#### Performance Considerations
- [ ] Main thread not blocked by heavy operations
- [ ] Memory usage reasonable
- [ ] Network requests optimized
- [ ] UI remains responsive during operations

#### Code Quality
- [ ] Follows DuckDuckGo architecture patterns (MVVM, DI, Coordinators)
- [ ] Uses DesignResourcesKit for colors/icons
- [ ] Proper error handling implemented
- [ ] Unit tests written/updated
- [ ] No anti-patterns introduced

#### Platform Considerations
**iOS-specific**:
- [ ] Works across iPhone/iPad form factors
- [ ] Handles multitasking correctly
- [ ] Supports iOS accessibility features
- [ ] Background app refresh behavior correct

**macOS-specific**:
- [ ] Window management handled properly
- [ ] Keyboard shortcuts work as expected
- [ ] Menu bar integration correct
- [ ] System services integration proper

#### Documentation Updates
- [ ] README files updated if needed
- [ ] API documentation reflects changes
- [ ] User-facing help content updated
- [ ] Internal documentation current

### Notes to Reviewer Guidelines

#### What to Highlight
- **Complex Logic**: Explain algorithmic decisions
- **Trade-offs**: Justify chosen approaches
- **Future Work**: Note planned improvements
- **Dependencies**: Mention external factors
- **Testing Gaps**: Acknowledge limitations

#### Specific Review Requests
```
# Good Examples
- "Please pay attention to the error handling in DataClearingService - I want to ensure we don't miss any edge cases"
- "The UI animation timing might need adjustment - please test on older devices"
- "I'm unsure about the Core Data migration - please review the schema changes carefully"

# Avoid Generic Requests
- "Please review"
- "Let me know what you think"
```

## Change Analysis Prompts

When analyzing code changes, consider:

1. **Files Modified**: What components are affected?
2. **Architecture Impact**: Does this follow established patterns?
3. **Integration Points**: What other features might be affected?
4. **User Journey**: How does this change the user experience?
5. **Privacy Implications**: What data is involved?
6. **Testing Coverage**: What scenarios need verification?

### Contributor Analysis for CC and Reviewer Selection

#### Identifying Contributors
Use git commands to analyze code ownership:

```bash
# Find contributors to specific files
git log --pretty=format:"%an <%ae>" --follow -- path/to/file.swift | sort | uniq -c | sort -nr

# Find recent contributors (last 6 months)
git log --since="6 months ago" --pretty=format:"%an <%ae>" --follow -- path/to/file.swift | sort | uniq -c | sort -nr

# Find contributors to specific functions/classes
git log -L :functionName:path/to/file.swift --pretty=format:"%an <%ae>" | sort | uniq -c | sort -nr
```

#### Contributor Evaluation Criteria
**Most Valuable Contributor** (Primary Reviewer):
1. **Recent Activity**: Active in the last 3-6 months on affected files
2. **Code Ownership**: Highest commit count in modified areas
3. **Domain Expertise**: Knowledge of the specific feature/component
4. **Code Quality**: History of thorough reviews and good architectural decisions

**CC Selection**:
- Contributors with significant commits to modified files
- Original authors of major components being changed
- Subject matter experts for the feature area
- Team leads or architects if architectural changes are involved

#### Analysis Examples

**For UI Changes**:
```bash
# Find contributors to view controllers and SwiftUI views
git log --pretty=format:"%an <%ae>" --follow -- "*ViewController.swift" "*View.swift" | sort | uniq -c | sort -nr
```

**For Service/Logic Changes**:
```bash
# Find contributors to service classes and business logic
git log --pretty=format:"%an <%ae>" --follow -- "*Service.swift" "*Manager.swift" | sort | uniq -c | sort -nr
```

**For Privacy/Security Changes**:
```bash
# Find contributors to privacy-related files
git log --pretty=format:"%an <%ae>" --follow -- "*Privacy*" "*Security*" "*Fireproof*" | sort | uniq -c | sort -nr
```

#### Reviewer Selection Logic
1. **Primary Reviewer**: Choose the contributor with:
   - Most commits in the affected area (recent activity weighted higher)
   - Demonstrated expertise in the specific domain
   - History of providing quality code reviews

2. **Secondary CCs**: Include:
   - Top 2-3 contributors to modified files
   - Original authors of significantly modified components
   - Team members with domain expertise

3. **Avoid Over-CCing**: Limit to 3-5 people unless it's a major architectural change

#### Example Analysis Output
```
Modified Files Analysis:
- BrowsingMenuViewController.swift: 15 commits by @alice, 8 by @bob, 3 by @charlie
- DataClearingService.swift: 12 commits by @bob, 7 by @alice, 5 by @diana

Recommended:
- Primary Reviewer: @alice (most active across both files)
- CC: @bob (major contributor), @diana (service expert)
```

## Common Pitfalls to Avoid

### Description Pitfalls
- ❌ Technical implementation details instead of user benefits
- ❌ Vague language like "fixes issues" or "improves performance"
- ❌ Missing context for complex changes
- ❌ No mention of user-visible changes

### Testing Steps Pitfalls  
- ❌ Generic steps that don't test the actual change
- ❌ Missing edge cases and error conditions
- ❌ No verification of integration with existing features
- ❌ Incomplete testing across platforms/configurations

### Risk Assessment Pitfalls
- ❌ Underestimating impact on privacy or security
- ❌ Not considering performance implications
- ❌ Missing compatibility issues
- ❌ Inadequate consideration of edge cases

## Template Usage

Always start with the complete template and fill each section thoughtfully:

```markdown
Task/Issue URL: [REQUIRED - Ask if not provided]
Tech Design URL: [Include if one exists for this change]
CC: [Contributors identified through git analysis - limit to 3-5 people]

### Description
[Clear, user-focused description of the change]

### Testing Steps
1. [Specific, actionable steps that verify the change works]
2. [Include edge cases and error conditions]
3. [Verify integration with existing features]

### Impact and Risks
Impact Level: [High/Medium/Low/None with justification]

#### What could go wrong?
[Specific scenarios and mitigation strategies]

### Quality Considerations
[Address relevant aspects: privacy, performance, compatibility, etc.]

### Notes to Reviewer
[Specific areas needing attention or known limitations]
```

## Pre-PR Creation Checklist

Before creating the PR, complete this analysis:

1. **Gather Required Information**:
   - [ ] Task/Issue URL obtained
   - [ ] Tech Design URL checked (include if exists)
   - [ ] Git analysis completed for contributor identification

2. **Analyze Code Changes**:
   - [ ] Files modified identified and categorized
   - [ ] Impact level assessed based on change type
   - [ ] Testing scenarios planned based on change analysis
   - [ ] Privacy and security implications evaluated

3. **Identify Stakeholders**:
   - [ ] Contributors to modified files identified via git log
   - [ ] Most valuable contributor selected as primary reviewer
   - [ ] Appropriate CCs selected (3-5 people max)
   - [ ] Domain experts included if needed

4. **Prepare Content**:
   - [ ] User-focused description written
   - [ ] Comprehensive testing steps created
   - [ ] Risk scenarios identified and mitigation noted
   - [ ] Quality considerations addressed
   - [ ] Specific reviewer guidance provided

Remember: A good PR description saves reviewer time and catches issues before they reach users. Always prioritize clarity and completeness over brevity.

## Exact PR Template

Use this exact template structure when creating PRs (unless `gh` client provides it automatically):

```markdown
<!--
Note: This template is a reminder of our Engineering Expectations and Definition of Done. Remove sections that don't apply to your changes.

⚠️ If you're an external contributor, please file an issue before working on a PR. Discussing your changes beforehand will help ensure they align with our roadmap and that your time is well spent.
-->

Task/Issue URL:
Tech Design URL:
CC:

### Description

### Testing Steps
<!-- Assume the reviewer is unfamiliar with this part of the app -->
1.
2.

### Impact and Risks
<!-- 
What's the impact on users if something goes wrong?

High: Could affect user privacy, lose user data, break core functionality
Medium: Could disrupt specific features or user flows
Low: Minor visual changes, small bug fixes, improvement to existing features
None: Internal tooling, documentation
-->

#### What could go wrong?
<!-- Describe specific scenarios and how you've addressed them -->

### Quality Considerations
<!-- 
Focus on what matters for your changes:
- What edge cases exist?
- How does this affect performance?
- What monitoring have you added?
- What documentation needs updating?
- How does this impact privacy/security?
-->

### Notes to Reviewer
<!-- Anything specific you want reviewers to focus on -->

---
###### Internal references:
[Definition of Done](mdc:https:/app.asana.com/0/1202500774821704/1207634633537039/f) | [Engineering Expectations](mdc:https:/app.asana.com/0/59792373528535/199064865822552) | [Tech Design Template](mdc:https:/app.asana.com/0/59792373528535/184709971311943)
```

## Template Usage Notes

- **HTML Comments**: Keep all HTML comments in the template as they provide important context
- **Empty Fields**: Fill in all applicable fields based on the analysis guidance above
- **Section Removal**: Remove sections that truly don't apply, but be conservative - most sections usually have some relevant content
- **Internal References**: Keep the footer links as they provide important process documentation

## PR Creation Tooling Instructions

### Method 1: GitHub CLI (Recommended)

#### Setup
```bash
# Install GitHub CLI (if not already installed)
brew install gh

# Authenticate with GitHub
gh auth login
```

#### Streamlined PR Creation Workflow

**Option A: Direct Creation (Fastest)**
```bash
# 1. Commit and push your changes
git add .
git commit -m "Brief description of changes"
git push -u origin $(git branch --show-current)

# 2. Create PR with minimal template (GitHub CLI will use repository template)
gh pr create \
  --title "Descriptive PR Title" \
  --body "Task/Issue URL: [REQUIRED]

### Description
Brief description of changes

### Testing Steps
1. Step 1
2. Step 2

### Impact and Risks
Impact Level: Low/Medium/High - Justification

### Quality Considerations
- Key considerations

### Notes to Reviewer
- Specific reviewer guidance" \
  --label "pending ship review" \
  --web
```

**Option B: Interactive Creation (Recommended for Complex PRs)**
```bash
# 1. Commit and push your changes (sets upstream)
git add .
git commit -m "Brief description of changes"
git push -u origin $(git branch --show-current)

# 2. Create PR interactively - opens editor with template
gh pr create --fill-verbose --web

# 3. Add labels if needed
gh pr edit --add-label "pending ship review"
```

**Option C: Web-First Approach (Most Flexible)**
```bash
# 1. Commit and push your changes (sets upstream)
git add .
git commit -m "Brief description of changes"
git push -u origin $(git branch --show-current)

# 2. Open PR creation page in browser
gh pr create --web
```

#### Contributor Analysis Helpers

**Quick Contributor Lookup**
```bash
# Function to add to your shell profile (.zshrc/.bashrc)
function pr-contributors() {
    echo "=== Top Contributors to Modified Files ==="
    git diff --name-only HEAD~1 | while read file; do
        echo "--- $file ---"
        git log --pretty=format:"%an" --follow -- "$file" | sort | uniq -c | sort -nr | head -3
    done
}

# Usage: Run after committing changes
pr-contributors
```

**GitHub Username Lookup**
```bash
# Get actual GitHub usernames (not just commit names)
gh api repos/duckduckgo/apple-browsers/collaborators --jq '.[].login' | sort
```

#### Common GitHub CLI Commands

```bash
# After creating PR
gh pr edit --add-reviewer @username1,@username2
gh pr edit --add-label "feature" --add-label "bug"
gh pr edit --add-assignee @me

# Check PR status
gh pr status
gh pr view --web

# Convert to draft
gh pr ready --undo

# Mark ready for review
gh pr ready
```

### Method 2: GitHub Web Interface

#### Steps
1. **Push your branch**:
   ```bash
   git checkout -b feature/your-feature-name
   git add .
   git commit -m "Your commit message"
   git push -u origin feature/your-feature-name
   ```

2. **Open GitHub in browser**:
   - Navigate to the repository
   - Click "Compare & pull request" button
   - Or go to "Pull requests" → "New pull request"

3. **Fill in PR details**:
   - Copy the exact template from the rule above
   - Fill in all sections based on your analysis (be thorough but concise)
   - Add reviewers and assignees
   - Set labels if needed
   - Add "pending ship review" label for UI/interaction changes

### Method 3: IDE Integration (Cursor/VS Code)

#### GitHub Extension
1. **Install GitHub PR extension** in Cursor/VS Code
2. **Sign in to GitHub** through the extension
3. **Create PR**:
   - Use Command Palette: `GitHub: Create Pull Request`
   - Fill in the template in the editor
   - Set reviewers and labels

#### Git Graph Extensions
- Use Git Graph or similar extensions to create PRs visually
- Right-click on your branch → "Create Pull Request"

### Method 4: Command Line + Web (Hybrid)

```bash
# 1. Push branch and get PR URL
git push -u origin feature/your-feature-name

# 2. Open PR creation page directly
gh pr create --web

# 3. Or get the URL to open manually
echo "https://github.com/duckduckgo/apple-browsers/compare/main...$(git branch --show-current)"
```

### Pre-Creation Workflow

#### Complete Workflow Example
```bash
# 1. Complete your work
git add .
git commit -m "Add delete browsing data to main menu"

# 2. Run contributor analysis
git log --pretty=format:"%an <%ae>" --follow -- path/to/modified/file.swift | sort | uniq -c | sort -nr

# 3. Create PR template file with analysis results
cat > pr-description.md << 'EOF'
Task/Issue URL: https://asana.com/your-task-url
Tech Design URL: 
CC: @alice @bob @charlie

### Description
Adds delete browsing data functionality to the main menu...
[Fill in based on analysis]
EOF

# 4. Push and create PR
git push -u origin feature/delete-browsing-data-menu
gh pr create --title "Add delete browsing data to main menu" --body-file pr-description.md --reviewer @alice
```

### Post-Creation Actions

#### After PR is Created
```bash
# Add additional reviewers if needed
gh pr edit --add-reviewer @username

# Add labels
gh pr edit --add-label "feature" --add-label "ui"

# Add "pending ship review" for UI/interaction changes
gh pr edit --add-label "pending ship review"

# Convert to draft if needed
gh pr ready --undo

# Mark as ready for review
gh pr ready
```

### Troubleshooting

#### Common Issues and Solutions

1. **Template not showing**: Check if repository has `.github/pull_request_template.md`
2. **Reviewer not found**: Ensure GitHub usernames are correct
3. **Permission issues**: Verify you have write access to the repository
4. **Branch protection**: Some branches may require specific approvals
5. **Uncommitted changes warning**: GitHub CLI warns about uncommitted files - this is normal if you have unrelated changes
6. **Branch has no upstream**: Use `-u` flag when pushing to set upstream tracking

#### Branch Upstream Management

**Set upstream during push (recommended):**
```bash
# Sets upstream and pushes in one command
git push -u origin $(git branch --show-current)
# or for specific branch name
git push -u origin your-branch-name
```

**Set upstream for existing branch:**
```bash
# If branch already exists remotely but no upstream set
git branch --set-upstream-to=origin/$(git branch --show-current)
# or
git push --set-upstream origin $(git branch --show-current)
```

**Check upstream status:**
```bash
# See which branches have upstream configured
git branch -vv

# Check current branch upstream
git rev-parse --abbrev-ref $(git branch --show-current)@{upstream}
```

**Fix common upstream issues:**
```bash
# Branch exists locally but not remotely
git push -u origin $(git branch --show-current)

# Branch exists remotely but no upstream tracking
git branch --set-upstream-to=origin/$(git branch --show-current)

# Upstream is set but branch was renamed
git branch -u origin/new-branch-name
```

#### GitHub CLI Debug
```bash
# Check GitHub CLI status
gh auth status

# List available reviewers
gh api repos/duckduckgo/apple-browsers/collaborators --jq '.[].login'

# Check PR status
gh pr list --author @me
```

#### Lessons Learned from Practical Usage

**🚫 Avoid These Pitfalls:**

1. **Multi-line commit messages in tools**: Some tools don't handle newlines well
   ```bash
   # ❌ Problematic in some contexts
   git commit -m "Line 1
   Line 2
   Line 3"
   
   # ✅ Use single line or -F flag
   git commit -m "Brief description"
   # or
   git commit -F commit-message.txt
   ```

2. **Creating temporary files unnecessarily**: 
   ```bash
   # ❌ Extra steps
   cat > pr-description.md << 'EOF'
   [content]
   EOF
   gh pr create --body-file pr-description.md
   rm pr-description.md
   
   # ✅ Direct approach
   gh pr create --body "content"
   # or
   gh pr create --fill-verbose  # Opens editor
   ```

3. **Manual contributor analysis**: 
   ```bash
   # ❌ Manual and error-prone
   git log --pretty=format:"%an <%ae>" --follow -- file.swift
   
   # ✅ Use helper function (see above)
   pr-contributors
   ```

4. **Guessing GitHub usernames**:
   ```bash
   # ❌ Guessing based on git names
   # "John Smith" -> "@john-smith" ???
   
   # ✅ Look up actual usernames
   gh api repos/duckduckgo/apple-browsers/collaborators --jq '.[].login' | grep -i john
   ```

**✅ Best Practices:**

1. **Always set upstream when pushing**: Use `git push -u origin branch-name` for new branches
2. **Use interactive mode for complex PRs**: `gh pr create --fill-verbose`
3. **Leverage repository templates**: Let GitHub CLI use existing templates
4. **Add labels immediately**: Include `--label` in creation command
5. **Open in browser**: Use `--web` flag to review and edit in browser
6. **Keep commits atomic**: One logical change per commit makes PR creation easier
7. **Check upstream status**: Use `git branch -vv` to verify tracking branches
